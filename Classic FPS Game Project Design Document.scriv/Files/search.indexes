<?xml version="1.0" encoding="UTF-8"?>
<SearchIndexes Version="1.0">
    <Documents>
        <Document ID="3">
            <Title>Front Matter</Title>
        </Document>
        <Document ID="7">
            <Title>Sample MS</Title>
        </Document>
        <Document ID="12">
            <Title>Non-Fiction Format</Title>
            <Text>NON-FICTION WITH SUB-HEADS

About This Template
When compiled (File &gt; Compile), this project will generate a document in standard manuscript format with sub-headings inside the chapters.

How To Use This Template
Edit the Title Page document to ensure it contains the correct information.
Create a new folder for each chapter and title each folder with the name of the chapter. If you don’t intend to use chapter names, just use something descriptive that tells you what the chapter is about. (You do not need to title the folders “Chapter One” and so on, as chapter numbering will be taken care of automatically during the Compile process.) The first chapter folder has been created for you with the placeholder title “Chapter Subtitle”.
Create a new text document for each sub-section within the chapter folders, giving each the title of the subheading you wish to appear in the text. You can nest text documents for smaller subheadings, like this:
￼
If you don’t require a foreword, move the “Foreword” document to the Trash folder. Alternatively, rename it “Preface” or “Introduction” if you prefer. If you would rather the foreword come after the table of contents—as is sometimes the case—drag the “Foreword” document and drop it below the “Contents” document.
If you are compiling to the RTF file format or if you have Microsoft Office installed and are compiling to DOC, DOCX, PDF or Print, you can create a table of contents. Before compiling, simply select all the documents you wish to be included in the contents listing (usually this will be the “Foreword”, all chapter folders, and “Endnotes”, but not the nested sub-sections), then go to Edit &gt; Copy Special &gt; Copy Documents as ToC. Paste into the “Contents” document below the “Contents” title. The resulting linked text and page number tags will be replaced with the final chapter names and page numbers in the compiled document. You can format the contents however you wish, for example removing the underlines or indenting subsections if you chose to include them. You don’t need to do this every time you compile, just when chapters have been added, deleted, renamed or moved around. (Note to Microsoft Word users: If you export to Word, you may need to generate a print preview in Word to force the page numbers to show up correctly—they may appear as question marks before doing so.) Deselect “Include in compile” for the Contents document in the inspector if you do not want it in your final output.
If you have no footnotes or endnotes in your text, be sure to delete the “Endnotes” document.
“Notes” and “Ideas” folders have been provided for your convenience, although you can replace them or create different top-level folders for your research materials if necessary (these are just regular folders that have had custom icons assigned to them using the Documents &gt; Change Icon feature.)
Compile your manuscript into standard manuscript format by selecting File &gt; Compile. The “Front Matter” folder is already selected for inclusion in the compile Contents pane.

Making Changes
There are various minor changes you can make to the settings to tweak this template so that it better suits your needs, as follows:
Chapter subtitles: If you don’t want to include the names of your chapter folders below the chapter numbering text in the compiled document, go to the “Formatting” pane in the Compile dialog and deselect “Title” in the list of elements to include. You will also need to edit the title prefix in the “Section Layout”.
Hierarchical numbering: If you require hierarchical numbering for sub-sections, choose “Non-Fiction with Sub-Heads (Hierarchical)” from the “Format As” menu in Compile. Alternatively, edit the “Section Layout” for each level in the “Formatting” pane of Compile and add the “&lt;$hn&gt;” (for “hierarchical numbering”) tag to the title prefixes. 
Page header: You can edit the page header in the “Page Settings” pane of the Compile dialog.
Font: You can use the “Formatting” pane in Compile to change the font used in the final document by selecting a row in the elements table, then clicking into the preview text to select it and clicking the “A” button in the format bar to change the font settings.

Sample Document
See the “Sample MS” PDF file in the Research folder for an example of a document that has been created using this template. This is what the “Draft” folder structure looked like in the binder for this sample document:

￼

Final Note
Scrivener project templates are flexible and are not intended to restrict you to a particular workflow. You can change, delete or move the files and folders contained in the template, and you can create your own templates by setting up a skeletal project with the files, folders and settings you would like to use for new projects and using File &gt; Save As Template.</Text>
        </Document>
        <Document ID="27">
            <Title>Ideas</Title>
        </Document>
        <Document ID="28">
            <Title>Notes</Title>
        </Document>
        <Document ID="29">
            <Title>Endnotes</Title>
            <Text> All footnotes will get inserted here upon print, and this bubble will be removed automatically.</Text>
        </Document>
        <Document ID="30">
            <Title>Foreword</Title>
        </Document>
        <Document ID="31">
            <Title>Contents</Title>
            <Text>











Contents
Title Page	&lt;$p&gt;
Foreword	&lt;$p&gt;
Contents	&lt;$p&gt;
Game Information	&lt;$p&gt;
Folder Structure	&lt;$p&gt;
Assets	&lt;$p&gt;
Material Bases	&lt;$p&gt;
PBR Settings	&lt;$p&gt;
Material Masters	&lt;$p&gt;
Parameter Names	&lt;$p&gt;
Material Functions and Layers	&lt;$p&gt;
Textures	&lt;$p&gt;
Particles	&lt;$p&gt;
Architectural Parameters	&lt;$p&gt;
Static Meshes	&lt;$p&gt;
Gameplay Base	&lt;$p&gt;
Gameplay States	&lt;$p&gt;
ClassicFPS Game Mode	&lt;$p&gt;
ClassicFPS Game State	&lt;$p&gt;
ClassicFPS Player State	&lt;$p&gt;
Gameplay Effects	&lt;$p&gt;
Character	&lt;$p&gt;
Default Character Properties	&lt;$p&gt;
Character Capabilities	&lt;$p&gt;
Action Bindings	&lt;$p&gt;
Axis Bindings	&lt;$p&gt;
Character Properties	&lt;$p&gt;
Character Property Value Modification	&lt;$p&gt;
Character Structure	&lt;$p&gt;
Character Operating Items	&lt;$p&gt;
Text Messages	&lt;$p&gt;
Character Animation	&lt;$p&gt;
AI	&lt;$p&gt;
Bot_Best	&lt;$p&gt;
Inventory	&lt;$p&gt;
Key Base	&lt;$p&gt;
Health Base	&lt;$p&gt;
Powerup Base	&lt;$p&gt;
Ammo Base	&lt;$p&gt;
Weapon Base	&lt;$p&gt;
Comparison of Weapons	&lt;$p&gt;
Physics Mesh Base	&lt;$p&gt;
Other Blueprint Objects	&lt;$p&gt;
Stair builder	&lt;$p&gt;
Pipe builder	&lt;$p&gt;
Fence builder	&lt;$p&gt;
Hose Builder	&lt;$p&gt;
Railing builder	&lt;$p&gt;
Jump pad	&lt;$p&gt;
Placeable shooters	&lt;$p&gt;
Day and night skies	&lt;$p&gt;
Lighted signs	&lt;$p&gt;
Monitors	&lt;$p&gt;
security cameras	&lt;$p&gt;
Teleporter	&lt;$p&gt;
Spawner	&lt;$p&gt;
Fan	&lt;$p&gt;
Sounds	&lt;$p&gt;
Actor Base	&lt;$p&gt;
Physics	&lt;$p&gt;
Collision	&lt;$p&gt;
Physical Surfaces	&lt;$p&gt;
Utility	&lt;$p&gt;
Tutorials	&lt;$p&gt;
Make A New Touchplate Switch	&lt;$p&gt;
New Weapon Creation	&lt;$p&gt;
Endnotes	&lt;$p&gt;
</Text>
            <Notes>Use `Edit &gt; Copy Special &gt; Copy Documents as ToC` if you are compiling to RTF or to PDF, DOC, DOCX or Print and have Microsoft Word installed.</Notes>
        </Document>
        <Document ID="36">
            <Title>Title Page</Title>
            <Synopsis>Title page to the manuscript.</Synopsis>
            <Text>
Deplorable Mountaineer
Moorefield, WV
https://deplorablemountain.wixsite.com/games
Deplorable.mountaineer@gmail.com

















Classic FPS Game Project Design Document

By Todd D. Vance

￼

© 2018 Deplorable Mountaineer</Text>
            <Notes>This is the title page of the manuscript. Note that “Compile As-Is” is ticked - this ensures that the title page’s formatting doesn’t get changed during the Compile process, even though the formatting of other text documents will be overridden to use a standard 12-point manuscript font.

The &lt;$projecttitle&gt; and &lt;$fullname&gt; tags get replaced with the information set in Project &gt; Meta-Data Settings… &gt; Project Properties. You can edit those settings or just replace this text altogether.</Notes>
        </Document>
        <Document ID="38">
            <Title>Game Information</Title>
            <Synopsis>Metadata for the entire game project

</Synopsis>
            <Text>Game Information</Text>
        </Document>
        <Document ID="39">
            <Title>Folder Structure</Title>
            <Synopsis>Hierarchy of asset-containing folders in the UE4 editor

</Synopsis>
            <Text>Folder Structure</Text>
        </Document>
        <Document ID="40">
            <Title>Assets</Title>
            <Synopsis>Major assets in the game project.</Synopsis>
            <Text>Assets</Text>
        </Document>
        <Document ID="41">
            <Title>Physics</Title>
            <Synopsis>Physical material and collision properties</Synopsis>
            <Text>Physics</Text>
        </Document>
        <Document ID="42">
            <Title>Utility</Title>
            <Synopsis>Assets for development use

</Synopsis>
            <Text>Utility

Default Grid for visualizing UV maps: 
Red Orange Yellow Yellow-Green Green Blue-Green Blue Blue-Violet Violet Red-Violet
J0 J1 J2 J3 J4 J5 J6 J7 J8 J9
I0 I1 I2 I3 I4 I5 I6 I7 I8 I9
H0 H1 H2 H3 H4 H5 H6 H7 H8 H9
G0 G1 G2 G3 G4 G5 G6 G7 G8 G9
F0 F1 F2 F3 F4 F5 F6 F7 F8 F9
E0 E1 E2 E3 E4 E5 E6 E7 E8 E9
D0 D1 D2 D3 D4 D5 D6 D7 D8 D9
C0 C1 C2 C3 C4 C5 C6 C7 C8 C9
B0 B1 B2 B3 B4 B5 B6 B7 B8 B9
A0 A1 A2 A3 A4 A5 A6 A7 A8 A9
￼

Version to test tileability of a mesh:
￼</Text>
        </Document>
        <Document ID="43">
            <Title>Tutorials</Title>
            <Synopsis>How to do various things with this game project</Synopsis>
            <Text>Tutorials

All assets made in tutorials are in a folder “Solutions/Tutorials” under the top-level Content folder so you can either check your work or just use the assets.</Text>
        </Document>
        <Document ID="46">
            <Title>Material Bases</Title>
            <Synopsis>Shaders used to create materials for this project</Synopsis>
            <Text>Material Bases</Text>
        </Document>
        <Document ID="51">
            <Title>PBR Settings</Title>
            <Synopsis>Physically-Based Rendering settings for certain common materials</Synopsis>
            <Text>PBR Settings
For game use only—I made up some of the values.
file:///D:/Documents/Repos/Deplorable_Mountaineer/Spreadsheets/Materials.ods
</Text>
        </Document>
        <Document ID="52">
            <Title>Material Masters</Title>
            <Synopsis>Master shaders that are parents of material instances</Synopsis>
            <Text>Material Masters
Base, Translucent_Expensive, Mask</Text>
        </Document>
        <Document ID="53">
            <Title>Parameter Names</Title>
            <Synopsis>Parameters reused in material masters</Synopsis>
            <Text>Parameter Names

file:///D:/Documents/Repos/Deplorable_Mountaineer/Spreadsheets/MaterialParameters.ods</Text>
        </Document>
        <Document ID="54">
            <Title>Material Functions and Layers</Title>
            <Synopsis>Shader functionality for materials</Synopsis>
            <Text>Material Functions and Layers
MF_MaskLerpRGB</Text>
        </Document>
        <Document ID="55">
            <Title>Textures</Title>
            <Synopsis>Images used for materials</Synopsis>
            <Text>Textures
Crosshairs: Cross, X, Dot, Triangle, Trefoil, Box, Circle, Rangefinder
Metal: dimpled, rough and scratchy, Rusty, Holey, verdigris, Brushed, galvanized, Corrugated, Grate, Fence, Louvred Vent, Duct
Rock: smooth, conglomerate, Sandy, Gravelly, Pitted, jagged, marble, slate, limestone, Granite, Sandstone
Icons: Default, Actor, Character, Weapon, Carryable
Cloth: Fine Weave, Coarse Weave, Carpet
Decals: bullet holes, footprints, Stain, signs, puddles, Dirt, Scratches,TODO
Wall: Plaster, wood, wood with grain, particleboard, Wood with knots,TODO brick, concrete, concrete block, Stone
Floor: tiles of various types and shapes, cobblestone, Concrete, Concrete grime, Concrete Panels, Concrete Tiles, Concrete grooved, Concrete Pitted, Concrete Plank-like TODO
Painted metal, colored glass, patterned cloth, etcTODO
.
Leather, Rubber, Plastic, Ceramic, etc. to match PhysMats

Ground: Dirt, Mud, Gravel, Grass, Snow, Patchy Grass, Ice, Dirty Ice, Rough Ice, Dirty Snow, Patchy Snow, Exposed Rock, muddy rocks, Moss, Dirt and Pebbles,TODO
 Ground with Foliage
Utility: noise, clouds, gradients
Hazard patterns
Grids and tile patterns, hex and square, etc.  Holey patterns, Vent louvre patterns, etc.
Diamond Plate, Duct, Planks, Parquet</Text>
        </Document>
        <Document ID="56">
            <Title>Particles</Title>
            <Synopsis>In-game particle effects</Synopsis>
            <Text>ParticlesTODO
Explosions, Hit effect, sparks (fire, electric, hammered metal), Fires, Beams, Projectile particles, Splash from water, slime, lava, Snow, Steam, Smoke,  Lightning, Shrapnel, Gibs, Dust, Contrail, Light halo,</Text>
        </Document>
        <Document ID="57">
            <Title>Actor Base</Title>
            <Synopsis>Parent blueprint for most actors</Synopsis>
            <Text>Actor Base</Text>
        </Document>
        <Document ID="58">
            <Title>Architectural Parameters</Title>
            <Synopsis>Recommended values for sizes of walls, windows, and so on.</Synopsis>
            <Text>Architectural Parameters

file:///D:/Documents/Repos/Deplorable_Mountaineer/Spreadsheets/Architectural.ods</Text>
        </Document>
        <Document ID="59">
            <Title>Static Meshes</Title>
            <Synopsis>Objects (with only basic functionality) that can be placed in a game level</Synopsis>
            <Text>Static Meshes
Window,
Shapes: Cube, sphere, slope, Square pyramid, Tetrahedron, Octahedron, Icosahedron, Torus, Plane, Cube Chamfer, Cube Inset, Cone, Platform, Circular platform, Platforms of various polygon shapes, Annular platform, Arrows
Arch: Walls, Walls with window/door openings
Pipes and joints, fence parts,. Stair parts, hose parts
Barrels, Crates, including exploding barrel, Boxes, bags
Bricks, Cement blocks, Rocks, Boulders
Foliage
Cones, Saw horses, Signs, Manhole covers
Trash cans, chairs, desks, tables, Benches, Couches, Barstools,
Grates, vents,</Text>
        </Document>
        <Document ID="60">
            <Title>Gameplay Base</Title>
            <Synopsis>Overall game structure</Synopsis>
            <Text>Gameplay Base</Text>
        </Document>
        <Document ID="61">
            <Title>Character</Title>
            <Synopsis>A humanoid game entity, either the player or a computer-controlled enemy, or even other types of pawns.</Synopsis>
            <Text>Character</Text>
        </Document>
        <Document ID="62">
            <Title>AI</Title>
            <Synopsis>Artificial intelligence for computer-controlled entities in the game</Synopsis>
            <Text>AI</Text>
        </Document>
        <Document ID="63">
            <Title>Inventory</Title>
            <Synopsis>Anything that can be picked up that changes the status of a character</Synopsis>
            <Text>Inventory
The pickup procedure is roughly as follows: if a pickup is overlapped, or if the player “operates” the pickup, its unique name (or just the regular name in the case of keys) is added to the list of pickups found.  Then it is determined whether or not the item can in fact be picked up.
If the player does not already have the item, it is picked up (depending on the pickup, it might be destroyed and its data added to the player rather than the object literally being attached to the player).  If the player already has the item but it is of a type that can be depleted (such as ammo or a weapon), the item the player has is replenished with the pickup’s amount (if it is positive) and the pickup is destroyed.  Otherwise, the pickup is ignored (though if it is a physics body, it may be nudged by the player).</Text>
        </Document>
        <Document ID="64">
            <Title>New Weapon Creation</Title>
            <Synopsis>Example of a pickup: a new weapon</Synopsis>
            <Text>New Weapon Creation
The following tasks need to be performed to create a new weapon.
Suppose {NAME} is the weapon’s name.
Create a folder under {ProjectDirectory}/Content/ClassicFPS/Pickups/Weapons called {NAME} (you may have to modify the name, such as replacing spaces with underscores or using camelcase or pascal case, to make it a valid folder name).  All weapon assets will go here (or in subdirectories).
Use a 3D digital content creation tool (such as Blender) to create a skeletal mesh and import it into Unreal Editor (be sure to create a skeleton for it).  It is recommended you use the Universal Gun Base as a guide for easy fitting to the default character Idle Rifle Hip pose.  Give it the name SK_{NAME} or something similar.  (Blender Tip: make sure your armature is not called “Armature” or there will be scaling bugs for some reason).
Open the SK_{NAME} mesh in UE4 and apply appropriate material(s) to it.
Open the skeleton and add a socket called “Muzzle” to an appropriate bone.  Move it to an appropriate location, and rotate it so the X axis points forward and the Y axis points right (from the gun holder’s point of view), and the Z axis points up.  If it is a projectile weapon, projectiles will be spawned here, so make sure it won’t collide with the gun.
Make sure the skeleton has a physics asset (single convex hull usually works well), and make sure the mesh uses it.
In the new folder you created, create a new blueprint whose parent blueprint is one of the weapon base blueprints in the directory {ProjectDirectory}/Content/ClassicFPS/Pickups/Weapons.  Most likely you do not want to use the simple BP_Weapon_Base as the parent, because you would have to reinvent the wheel a bit to get it working.  Use one of the others.
Name this new blueprint BP_{NAME} (again the name might need to be modified to make it a valid blueprint name).
Copy the data table from the folder {ProjectDirectory}/Content/ClassicFPS/Pickups/Weapons to the newly created folder.  The data table is called DefaultWeaponProperties.  Rename the copy to {Name}Properties or something similar.
In the BP_{NAME} blueprint, change the icon if you wish (in the Actor section of the Details panel in the Class Defaults).  You might select from an existing icon, which has the string “Icon” in its name for easy searching.
In the BP_{NAME} Blueprint, change the crosshair if you wish (in the Actor|Pickup|Weapon section of the details panel in the Class Defaults).  You might select from an existing crosshair image, which has the string “Crosshair” in its name for easy searching.
In the BP_{NAME} Blueprint, change the Pickup Mesh, First Person Mesh, and Third Person Mesh skeletal mesh values to the skeletal mesh you created (you must use a skeletal mesh weapon; it must have a socket at the appropriate location called “Muzzle”).  Optionally, the pickup, first person, and third person meshes can be different (e.g. first person mesh very detailed with ammo counters, etc.)
In the {NAME}Properties data table, adjust values for fields as needed.  For all weapons, you likely want to change the name, possibly the UI colors and additional tags, current ammo (the ammo it starts with), ammo capacity, and Time Between Shots.  Other properties will change depending on what the weapon type is.  For example, the Hitscan requires Damage Per Shot and Range to be set.  Currently Crosshair and Icon are not set from this table, but are set directly in the blueprint.
In the BP_{NAME} Blueprint, change the Data Table to Use variable to point to your newly-created data table.
Note that if you set these properties in the blueprint, they will be overridden by the data table!  Change the properties in the data table instead.  Note some things like the crosshair and icon are still selected in the blueprint; for those, consider the data table entries to be “documentation”.
To make the weapon useable, it needs to be added to the ClassicFPS_GameMode: open the {ProjectDirectory}/Content/ClassicFPS/Gameplay/ClassicFPS_GameMode blueprint.  Under MyBlueprint, select the Weapon Slots array variable.  The variable is now shown in the Details panel.
Add another entry to the array, and select your BP_{NAME} weapon as its value.  Then rearrange the array at will: the 0th element will be the weapon slot 1, the 1st element the weapon slot 2, and so on that are mapped (by default) to the keys 1, 2, 3, and so on.</Text>
        </Document>
        <Document ID="65">
            <Title>Physics Mesh Base</Title>
            <Synopsis>An item that cna be moved or picked up, but no significant functionality other than that</Synopsis>
            <Text>Physics Mesh Base</Text>
        </Document>
        <Document ID="66">
            <Title>Other Blueprint Objects</Title>
            <Synopsis>Other actors used in the game</Synopsis>
            <Text>Other Blueprint Objects
Characters, Weapons, ammo, pickups, projectiles, Pickup Spawner</Text>
        </Document>
        <Document ID="67">
            <Title>Sounds</Title>
            <Synopsis>Sound effect assets for the game</Synopsis>
            <Text>Sounds
file:///D:/Documents/Repos/Deplorable_Mountaineer/Spreadsheets/Sounds.ods
Guns firing, reloading
Footsteps, thud from fall
Object dropped
Projectile impact
Door open close lock
computery
fans
Elevator
Pickup, injury, death sounds
Powerup use sounds
Menu UI sounds
Fire, Explosion, Steam hiss
Rocket travel
Grenade clink
Running water
Wind
Outdoor ambience
City Ambience
Starter music
Water drip</Text>
        </Document>
        <Document ID="68">
            <Title>Make A New Touchplate Switch</Title>
            <Synopsis>Example of a switch object: a character-operated touchplate</Synopsis>
            <Text>Make A New Touchplate Switch
A touchplate is a type of switch that is activated by a character standing on it.  This tutorial can be used as a guide for making other kinds of switches as well.  Switches already in the project include the BP_Switch_Toggle (a standard light switch the character “operates”) and BP_Switch_Button (a big button to push the character “operates”).  These can be studied for further information.
Setup.  Open (a copy of) the ClassicFPS project.  In the Content Browser, navigate to the top-level Content folder, and ensure there is a folder called Tutorials, and in the Tutorials folder, create a new folder called Touchplate.
Create a touchplate mesh.  This can be done in Blender, 3DS Max, Maya, or some other 3D content-generation package.  Or you can use the SM_Touchplate asset already in the Content/Solutions/Tutorials/Touchplate folder.  For this tutorial, I shall use the free Blender.
Open Blender and delete the default Cube Mesh
Shift-A to add mesh, select Mesh→Cylinder.
In the Add Cylinder properties panel (by default, lower left side), ensure the following properties:
Vertices: 32
Radius: 1
Depth: .1
Cap Fill Type: Ngon
Generate UVs: Yes
Align to View: No
Location: x=0.000, y=0.000, z=0.000
Rotation: x=0◦, y=0◦, z=0◦
Ctrl-S to save.  Choose an appropriate directory and filename (such as “Touchplate.blend”), and save it.
Make sure the touchplate mesh is selected (right-click to select), and nothing else.
In the top menubar, select File→Export→FBX (.fbx)
In the Export FBX properties panel (by default, lower left side), ensure the following properties under the given tabs:
Main Tab:
Version: FBX 7.4 binary
Scale: 1.00
Apply Scale: All Local
Forward: -Z Forward
Up: Y Up
Selected options: all of them (Empty, Camera, Lamp, Armature, Mesh, Other)
!EXPERIMENTAL! Apply Transform: No
Custom Properties: No
Path Mode: Auto
Batch Mode: Off
Geometry Tab
Apply Modifiers: Yes
Use Modifiers Render Setting: Yes
Smoothing: Face
Loose Edges: No
Tangent Space: No
Armature Tab
Only Deform Bones: No
Add Leaf Bones: No
Primary Bone Axis: Y Axis
Secondary Bone Axis: X Axis
Armature Node Type: Null
Animation Tab
Baked Animation: Yes
Key All Bones: Yes
NLA Strips: Yes
D: All Actions: Yes
Force Start/End Keying: Yes
Sampling Rate: 1.00
Simplify: 1.00
Navigate to your Unreal project, then Content directory, then Tutorials directory, then Touchplate directory.
Set the name of the file to save to be SM_Touchplate.fbx
Click the Export FBX button.
Go to UE4 Editor.
You should see a popup; select “Import” (if not, click the Import button in the content browser, navigate to where you saved the FBX file, and import it).
Now you see an FBX Import Options panel.  Ensure the following properties:
Skeletal Mesh: No
Auto Generate Collision: Yes
Leave advanced properties at their defaults
Transform: leave default all zero except scale is 1.0
Miscellaneous: Convert Scene yes, Force Front X Axis No, Convert Scene Unit No, advanced properties, leave defaults
LOD Settings: Auto Compute LOD Distance Yes
Materials: Search Location: Local, Import Materials: no, Import Textures: no, leave advanced options as defaults
Click Import All.
Your touchplate mesh is now in the Content Browser under Content/Tutorials/Touchplate.
Optional: give the touchplate a material of some kind (such aSs MI_Rubber_Blue2).
Close the static mesh editor window.
Create a Touchplate Blueprint.
In the Content Browser in the UE4 Editor, navigate to the Content/Tutorials/Touchplate folder, the same folder where the SM_Touchplate mesh asset is.
Right click, then select Blueprint Class.  A popup appears titled “Pick Parent Class”
If necessary, click the arrow next to “All Classes” to show all classes.  In the search bar, begin typing BP_Switch_Base.  You do not need to type it all; the BP_Switch_Base class will appear in the hierarchy below the search box.
Select BP_Switch_Base (because of a bug, you might have to select it twice to get it highlighted).  Then click the green Select button at the bottom of the popup.
A new blueprint with the name “NewBlueprint” will appear in the content browser.  While the name is still highlighted (if it is not, clicking the asset and hitting F2 will let you rename it), change its name to BP_Touchplate.
Double click the new BP_Touchplate asset to open the blueprint editor for it.
Make sure the Viewport tab is active (you will see a white sphere in the viewport).
To the left (by default), in the Components panel, click the green Add Component button.  A dropdown menu will appear
Start typing “Static Mesh”, and select the Static Mesh option (not either of the two instanced static mesh options, just plain “Static Mesh”).  Accept the entry.  Hit ENTER to keep the name “StaticMesh” without renaming it.
With the StaticMesh component still highlighted, find the Static Mesh section of the Details panel (by default, on the right).
Click the box with the down arrow on it and start typing “SM_Touchplate”, and when it comes up, select SM_Touchplate for the static mesh.  The newly-created Touchplate mesh will appear in the viewport.
Find the Collision section in the Details tab.  Ensure Generate Overlap Events is checked, and that Collision Presets is set to Overlap All Dynami9c
Open the Event Graph tab.  If the tab is not there, you can open it by double-clicking the Event Graph item under Graphs in the My Blueprint panel (by default, to the left below the Components panel; if the My Blueprint panel is not there, it can be opened from the menu bar, Window menu).  There is a bug in some versions of UE4 so if clicking the EventGraph item doesn’t work, right-click and select “Open in New Tab”.
Highlight the Static Mesh component in the Components tab.
To the right (by default), in the Details tab, scroll down, and find a green button with a plus sign in it labeled On Component Hit.  Click it.  An On Component Begin Overlap (StaticMesh) node appears in the Event Graph blueprint.
On the On Component Begin Overlap event node, click and drag rightward from the right-pointing white-outlined arrow to place a new node.  When you let go of the mouse button, an Executable Actions popup will appear.
Type “Toggle Action” in the search bar, and when it appears, click on Toggle Action.  A new node should appear called Toggle Action, connected to the On Component Begin Overlap node by a white line.  (This represents an execution path from the event node to the toggle action node, so that whenever the touchplate is hit, the toggle action event will be thrown.  In the Switch Base, this toggle action just toggles the switch between on and off).
Compile the blueprint (Click the compile button in the toolbar), then save the blueprint (click the Save button in the toolbar).  Close the blueprint.
Place the Touchplate in the Level and Wire it up to something.  
Create a new level: select File→New Level, and click Default.  Use Ctrl-S to save it, and give it the name Touchplate_Test, and save it in the Content/Tutorials/Touchplate directory.
Ensure the Content Browser is in Content/Tutorials/Touchplate where you can see the BP_Touchplate and the SM_Touchplate assets.
Drag the BP_Touchplate asset into the scene in the viewport, and set it on the default platform somewhere.  Currently the touchplate does not do anything because it is not connected to anything controllable.
Navigate to Content/ClassicFPS/Environment/Props/Lights in the Content Browser, and find BP_Lamp_Ceiling.  Drag this asset into the scene and move it somewhere reasonable (lift it up above the platform by selecting the viewport, clicking W to show the Move widget, and clicking and dragging the blue arrow on the Move widget) to make it visible.
Click the Touchplate actor in the scene to select it.
In the details panel, in the State section, are a lot of inputs.  We shall only use a few of them. Click the white Plus sign to the right of Controlled Objects to add a new array element. Element 0, set to the value None, appears
Click the box containing None and the down-pointing triangle to see a list of assets in the current scene.  Find and select the BP_Lamp_Ceiling asset.  Thus, this touchplate will control the lamp we just placed in the level.
Click the right-pointing right triangle next to On Enter State Actions.  Currently the action for state 0 is None.  Change that to “Off”, so when the touchplate is in state 0, the light will be turned off.
Click the white Plus sign to the right of On Enter State Actions to add another element to the array.  A new element 1 will appear, with value None.
Change the None to “On”.  Thus, when the touchplate enters state 1, the light will be turned on.
Note the touchplate’s current state is 0.  Thus, it starts “Off”.  Let us make sure the light is off so the states are sync’d when the level is played.  Click the light asset in the scene.  In the controllable section, click the right-pointing white arrow next to Light.  Change the Light is On checkbox to “Unchecked”.  In the scene, the light will turn off.  Now the light and the touchplate are sync’d, both in the “Off” state.
Test by clicking the Play button in the toobar.  When you walk on the touchplate, the light should turn on.  When you walk away and walk back onto the touchplate, the light should turn off.
Type CTRL-S to save the level.
</Text>
        </Document>
        <Document ID="69">
            <Title>Spreadsheets</Title>
        </Document>
        <Document ID="70">
            <Title>Properties</Title>
            <Synopsis>Properties most project-specific actors have</Synopsis>
            <Text>Properties
Name
Unique Name (just use name-in-world)
Icon
Colors
Additional Tags (automatically populates list of actor tags)</Text>
        </Document>
        <Document ID="71">
            <Title>Controllable Objects</Title>
            <Synopsis>Objects that can be controlled by a switch object </Synopsis>
            <Text>Controllable Objects
Controllable objects have actions (of type Name) that can be called by a switch (a switch is really a state machine).  Doors and Lights are examples, but so is a switch: so one switch can affect the state of another, allowing three-way switches, combo lock switches, etc.
A controllable object inherits from the BPI_Controllable interface, which provides the method “Do Action”, which takes an Action:Name input to select the action, as well as input parameters (which are used or ignored depending on the action) Float Input:Float, Vector Input:Vector, Rotator Input:Rotator,  Color Input:Linear Color, Transform Input:Transform, and Name Input:Name.  It returns Success:Bool, True if successful, and False if not (for example, parameter out of range or action of given name does not exist).
One way to implement this method is to switch on the Action name, each branch calling a function named the same as the action and taking exactly the arguments they need.  Another way is to inherit from BP_Controllable, and set the Allowed Actions array to be the list of action names, and override Do Action By Number to switch on the integer index of the action and perform the actions using the variables Float Input, etc., for inputs.</Text>
        </Document>
        <Document ID="72">
            <Title>Doors</Title>
            <Synopsis>Can be opened or closed by a switch, overlapping a volume, or operating</Synopsis>
            <Text>Doors</Text>
        </Document>
        <Document ID="73">
            <Title>Lights</Title>
            <Synopsis>Light that can be turned on or off</Synopsis>
            <Text>Lights</Text>
        </Document>
        <Document ID="74">
            <Title>Switches</Title>
            <Synopsis>Switches: controls a controllable, and is also itself a controllable</Synopsis>
            <Text>Switches</Text>
        </Document>
        <Document ID="75">
            <Title>Gameplay States</Title>
            <Synopsis>Menus, the game itself, end screens, and so on</Synopsis>
            <Text>Gameplay States</Text>
        </Document>
        <Document ID="77">
            <Title>ClassicFPS Game Mode</Title>
            <Synopsis>The normal first-person shooter single player against computer-controlled enemies game mode for most levels</Synopsis>
            <Text>ClassicFPS Game Mode
Player is spawned at the beginning of the level, or at a saved point
When player dies, can respawn at beginning or a saved point (state reset to the point)
Upon reaching the end of level volume, there is a summary screen followed by starting the next level, keeping all inventory except keys.
The Game Mode class maintains the list of weapons and default slots, up to 9 of which can be mapped to keys.</Text>
        </Document>
        <Document ID="78">
            <Title>ClassicFPS Game State</Title>
            <Synopsis>State information carried between levels</Synopsis>
            <Text>ClassicFPS Game State
Current level
Levels Completed
Strength Achieved</Text>
        </Document>
        <Document ID="79">
            <Title>ClassicFPS Player State</Title>
            <Synopsis>State information specific to a character that is maintained between levels and sessions</Synopsis>
            <Text>ClassicFPS Player State
Skill Level
Name</Text>
        </Document>
        <Document ID="80">
            <Title>Gameplay Effects</Title>
            <Synopsis>Visual, audio, etc. effects for various game events</Synopsis>
            <Text>Gameplay Effects
Hurt screen
Red tint, red dirt mask, extreme vignetting, extreme chromatic abberation; effect stronger as health decreases

Dead screen
Night Vision screen
Turbo screen
Low health screen?
Health increase screen
Shield used screen
Effects when enemy hit or killed
Pickup Effects
Low Ammo/Health/Inventory effects
In Battle Effects
Boredom Effects
Goal Achieved Effects</Text>
        </Document>
        <Document ID="81">
            <Title>Default Character Properties</Title>
            <Synopsis>Spreadsheet of properties for the default character</Synopsis>
            <Text>Default Character Properties
file:///D:/Documents/Repos/Deplorable_Mountaineer/Spreadsheets/DefaultPlayerCharacter.ods</Text>
        </Document>
        <Document ID="82">
            <Title>Character Capabilities</Title>
            <Synopsis>Spreadsheet for estimating things like hjump distance, etc. of a character</Synopsis>
            <Text>Character Capabilities
Assuming for falling damage, falling on default surface, health at 100 and no shielding.  Computed values are rounded.  Max survivable fall height actually varies according to physmat of surface hit.  For jump height, remember to add max step height to determine max height of platform that can be jumped onto.  Also all values appear to be approximate: in-game values differ slightly from computed values for reasons the author doesn’t know.
file:///D:/Documents/Repos/Deplorable_Mountaineer/Spreadsheets/CharacterCapabilitiesComputed.ods

Formulas used (assumes no air resistance, assumes character movement is physically accurate):
Jump Height: jump velocity * time + 0.5*-980*G*time*time
Velocity curve when jumping: Jump velocity – 980*G*time
Time for (single) jump: time = jump velocity / 980 / G
Double jumps double the height and time, but not velocity.</Text>
        </Document>
        <Document ID="83">
            <Title>Action Bindings</Title>
            <Synopsis>Key bindings for character actions</Synopsis>
            <Text>Action Bindings
file:///D:/Documents/Repos/Deplorable_Mountaineer/Spreadsheets/DefaultActionBindings.ods</Text>
        </Document>
        <Document ID="84">
            <Title>Axis Bindings</Title>
            <Synopsis>Analog Key, mouse, etc. bindings, such as turning or looking up and down</Synopsis>
            <Text>Axis Bindings
file:///D:/Documents/Repos/Deplorable_Mountaineer/Spreadsheets/DefaultAxisBindings.ods</Text>
        </Document>
        <Document ID="85">
            <Title>Character Properties</Title>
            <Synopsis>Properties common to all characters</Synopsis>
            <Text>Character Properties
file:///D:/Documents/Repos/Deplorable_Mountaineer/Spreadsheets/DefaultCharacterProperties.ods</Text>
        </Document>
        <Document ID="86">
            <Title>Character Property Value Modification</Title>
            <Synopsis>How various character properties are modified in the game</Synopsis>
            <Text>Character Property Value Modification</Text>
        </Document>
        <Document ID="87">
            <Title>Character Structure</Title>
            <Synopsis>Details on how the character is put together from its components</Synopsis>
            <Text>Character Structure
Note that there is currently a bug (as of Version 4.18.3) in UE4 that causes the third-person character mesh to sometimes disappear in a level when the game isn’t being played.  The first-person arms mesh is still visible, though.  It can be fixed by recompiling the appropriate character blueprint.  It appears to be harmless: the mesh reappears when you play the game.
A character has a BP_Character_Base as its parent, which in turn has the built-in Character class as its parent.  Thus it already comes with a Capsule component as its root, as well as an arrow component (for convenience), and a skeletal mesh component.  It also has a character movement component.
The assets in this project are designed for a character 192cm high and 84cm wide, so the capsule half-height is 96, and the capsule radius is 42.   One can use a different-sized character, but things like doorway sizes might have to be adjusted.
The camera boom is attached to the capsule component, and the camera is attached to the camera boom.  By shortening the camera boom to 0 length, we achieve first-person mode; otherwise, there is an adjustable-length boom third person mode.
The camera has a first-person arms mesh attached to it, visible only to the owning player and in first person mode (in which the other mesh, the third-person mesh, is made invisible to the owning player, but not to others).</Text>
        </Document>
        <Document ID="88">
            <Title>Character Operating Items</Title>
            <Synopsis>Details on what happens when a player presses the &quot;Operate&quot; button</Synopsis>
            <Text>Character Operating Items
When a character “operates” an item, it first checks if the item is an actor implementing the BPI_Operatable interface.  If so, it calls the actor’s Operate function.
If not, it checks if it is a pickup.  If so, it tries to pick up the item.  If not or if picking up fails, it checks if it simulates physics.  If so, and if it is not too heavy, the character carries the item.
When the Operate action occurs and the character is already carrying something, it drops the item instead of performing the usual Operate procedure.</Text>
        </Document>
        <Document ID="89">
            <Title>Text Messages</Title>
            <Synopsis>Messages that entities in the game can send to each other</Synopsis>
            <Text>Text Messages
Characters can receive text messages.  In a blueprint, on a Character actor, just call “Receive Text Message” with the appropriate inputs.
￼
Mostly, the messages have no effect.  But with a player character, the message is displayed on the Player’s HUD.</Text>
        </Document>
        <Document ID="90">
            <Title>Character Animation</Title>
            <Synopsis>How the character skeletal mesh moves</Synopsis>
            <Text>Character Animation
Animation for the default third-person character mesh is controlled by the ABP_Character blueprint.
On each animation update, the BP_Character actor is queried for rotation, velocity, and whether jump button and crouch button are down.  The Direction, Speed, Horizontal Speed, Falling, Enable Jump, and Crouching variables are set as a result.  These variables then control the animation through the state machine (“Locomotion”).  After a brief delay, Enable Jump is reset.</Text>
        </Document>
        <Document ID="91">
            <Title>Bot_Best</Title>
            <Synopsis>The default AI bot for humanoid enemies</Synopsis>
            <Text>Bot_Best
Following are definitions of Bot “substates”. Numbers mentioned are usually configurable.  Blue</Text>
        </Document>
        <Document ID="92">
            <Title>Wants Health</Title>
            <Synopsis>Bot would like to look for health</Synopsis>
            <Text>Wants Health
True if health is less than  75%</Text>
        </Document>
        <Document ID="93">
            <Title>Needs Health</Title>
            <Synopsis>Bot strongly wants to look for health</Synopsis>
            <Text>Needs Health 
True if health is less than 50%</Text>
        </Document>
        <Document ID="94">
            <Title>Wants Ammo</Title>
            <Synopsis>Bot would like to look for ammo</Synopsis>
            <Text>Wants Ammo
True if less than 100 hit points worth of ammo left</Text>
        </Document>
        <Document ID="95">
            <Title>Focused Ammo is Full</Title>
            <Synopsis>The ammo pickup the bot is focused on cannot be used because the bot is full on that ammo</Synopsis>
            <Text>Focused Ammo is Full 
True if the Focused Ammo is set and the bot has that weapon and it can take no more ammo</Text>
        </Document>
        <Document ID="96">
            <Title>Focused Powerup is Full</Title>
            <Synopsis>The powerup pickup the bot is focused on cannot be used because the bot is full on that powerup charge</Synopsis>
            <Text>Focused Powerup is Full 
True if the Focused Powerup is set and the bot has that powerup and it can take no more charge</Text>
        </Document>
        <Document ID="97">
            <Title>Needs Ammo</Title>
            <Synopsis>Strongly wants to pick up some ammo</Synopsis>
            <Text>Needs Ammo
True if less than 50 hit points worth of ammo  left</Text>
        </Document>
        <Document ID="98">
            <Title>In Mortal Danger</Title>
            <Synopsis>Bot is near death and takes emergency action</Synopsis>
            <Text>In Mortal Danger
True if health is less than 25%</Text>
        </Document>
        <Document ID="99">
            <Title>Has Ammo</Title>
            <Synopsis>Bot still has some ammo left</Synopsis>
            <Text>Has Ammo
True if has any ammo in any possessed weapon</Text>
        </Document>
        <Document ID="100">
            <Title>Knows Enemy Location</Title>
            <Synopsis>Bot knows where the enemy is (generally, means can see enemy)</Synopsis>
            <Text>Knows Enemy Location
True if enemy (i.e. the player) detected by sight, hearing, or being shot at</Text>
        </Document>
        <Document ID="101">
            <Title>Suspects Enemy Location</Title>
            <Synopsis>Bot can guess with high assurance where the enemy is</Synopsis>
            <Text>Suspects Enemy Location
True if enemy detected less than 5 seconds ago</Text>
        </Document>
        <Document ID="102">
            <Title>In Attack Range of Enemy</Title>
            <Synopsis>Bot is close enough to enemy to begin attacking</Synopsis>
            <Text>In Attack Range of Enemy
True if enemy within range of its current weapon</Text>
        </Document>
        <Document ID="103">
            <Title>Focused Bot</Title>
            <Synopsis>Another bot the current bot has detected</Synopsis>
            <Text>Focused Bot
Teammate bot that is referred to in the next three boolean variables.</Text>
        </Document>
        <Document ID="104">
            <Title>Focused Bot Forward</Title>
            <Synopsis>A position in front of the focused bot</Synopsis>
            <Text>Focused Bot Forward
A point 400 Unreal Units forward from the Focused Bot</Text>
        </Document>
        <Document ID="105">
            <Title>Focused Bot Backward</Title>
            <Synopsis>A position behind the focused bot</Synopsis>
            <Text>Focused Bot Backward
A point 400 Unreal Units backward from the Focused Bot</Text>
        </Document>
        <Document ID="106">
            <Title>Near Another Bot Neither Attacking or Fleeing</Title>
            <Synopsis>Found a bot just wandering around, so get out of his way</Synopsis>
            <Text>Near Another Bot Neither Attacking or Fleeing
If neither Attacking nor Fleeing, nor Needs Ammo nor Needs Health, and suspects location of other bot (on same team), within 4000 Unreal Units of the bot, and the bot is neither attacking or fleeing</Text>
        </Document>
        <Document ID="107">
            <Title>Near Another Bot that is Attacking</Title>
            <Synopsis>Found a bot attacking, so go help attack</Synopsis>
            <Text>Near Another Bot that is Attacking
If neither Attacking nor Fleeing, nor Needs Ammo nor Needs Health, and suspects location of other bot (on same team), within a range of 4000 Unreal Units of the bot, and the bot is Attacking</Text>
        </Document>
        <Document ID="108">
            <Title>Near Another Bot that is Fleeing</Title>
            <Synopsis>Found a bot fleeing, so attack his attacker</Synopsis>
            <Text>Near Another Bot that is Fleeing
If neither Attacking nor Fleeing, nor Needs Ammo nor Needs Health, and suspects location of other bot (on same team), within 4000 Unreal Units of the bot, and the bot is Fleeing</Text>
        </Document>
        <Document ID="109">
            <Title>Focused Health</Title>
            <Synopsis>Current health pickup bot knows about and is headed for</Synopsis>
            <Text>Focused Health
Health that is referred to in the next two boolean variables</Text>
        </Document>
        <Document ID="110">
            <Title>Near Health</Title>
            <Synopsis>Is close to a health pickup</Synopsis>
            <Text>Near Health
If Knows Location of Health and health is within 4000 Unreal Units of self</Text>
        </Document>
        <Document ID="111">
            <Title>Knows Location of Health</Title>
            <Synopsis>Knows where a health pickup (likely) is</Synopsis>
            <Text>Knows Location of Health
If knows location of health (bot never forgets if has seen the health, or if it is granted sufficient “knowledge of map” even if it hasn’t seen the health; but will forget once the health is taken up unless it is a respawnable health)</Text>
        </Document>
        <Document ID="112">
            <Title>Bored</Title>
            <Synopsis>Bot is tired of current state and wants to try a different state for a while</Synopsis>
            <Text>Bored
In the same state for more than 60 seconds (with some randomness)</Text>
        </Document>
        <Document ID="113">
            <Title>Focused Waypoint</Title>
            <Synopsis>A patrol point a bot is focused on</Synopsis>
            <Text>Focused Waypoint
Waypoint that is referred to in the next boolean variable</Text>
        </Document>
        <Document ID="114">
            <Title>Near Waypoint</Title>
            <Synopsis>A bot is close to a waypoint</Synopsis>
            <Text>Near Waypoint
If a waypoint is within 4000 Unreal Units of self</Text>
        </Document>
        <Document ID="115">
            <Title>Far From Home</Title>
            <Synopsis>Bot is far from all his waypoints</Synopsis>
            <Text>Far From Home
If no waypoint is within 10000 Unreal Units of self and there are waypoints for this bot</Text>
        </Document>
        <Document ID="116">
            <Title>Focused Ammo or Weapon</Title>
            <Synopsis>Ammo or weapon pickup a bot is headed for</Synopsis>
            <Text>Focused Ammo or Weapon
Ammo or weapon that is referred to in the next two boolean variables</Text>
        </Document>
        <Document ID="117">
            <Title>Near Ammo or Weapon</Title>
            <Synopsis>A bot is close to an ammo or weapon pickup</Synopsis>
            <Text>Near Ammo or Weapon
If Knows Location of Ammo or Weapon and ammo or weapon is within  4000 Unreal Units of self</Text>
        </Document>
        <Document ID="118">
            <Title>Knows Location of Ammo or Weapon</Title>
            <Synopsis>A bot knows the (likely) location of an ammo or weapon pickup</Synopsis>
            <Text>Knows Location of Ammo or Weapon
If knows location of ammo or weapon (bot never forgets if has seen the health, or if it is granted sufficient “knowledge of map” even if it hasn’t seen the ammo or weapon; but will forget once the ammo or weapon is taken up unless it is a respawnable ammo or weapon)</Text>
        </Document>
        <Document ID="119">
            <Title>Focused Powerup</Title>
            <Synopsis>Powerup a bot is headed for
</Synopsis>
            <Text>Focused Powerup
Powerup that is referred to in the next two boolean variables</Text>
        </Document>
        <Document ID="120">
            <Title>Near Powerup</Title>
            <Synopsis>The bot is close to a powerup
</Synopsis>
            <Text>Near Powerup
If Knows Location of Powerup and powerup is within  4000 Unreal Units of self</Text>
        </Document>
        <Document ID="121">
            <Title>Knows Location of Powerup</Title>
            <Synopsis>Bot knows the (likely) location of a powerup</Synopsis>
            <Text>Knows Location of Powerup
If knows location of powerup (bot never forgets if has seen the powerup, or if it is granted sufficient “knowledge of map” even if it hasn’t seen the powerup; but will forget once the powerup is taken up unless it is a respawnable powerup)</Text>
        </Document>
        <Document ID="122">
            <Title>States</Title>
            <Synopsis>AI states the bot can be in</Synopsis>
            <Text>States
Here are the states the Bot can be in.  The conditionals for transitioning to other states are listed in priority order, that is the first is checked, then if no transition occurs, the second is checked, and so on.</Text>
        </Document>
        <Document ID="123">
            <Title>Attacking</Title>
            <Synopsis>Bot is attacking an enemy</Synopsis>
            <Text>Attacking
If Suspects Enemy Location AND (In Mortal Danger OR NOT Has Ammo), transition to Fleeing
If Needs Health and Near Health, transition to Collecting Health
If Needs Ammo and Near Ammo or Weapon and can use that ammo or weapon, transition to Collecting Ammo or Weapon
If NOT Suspects Enemy Location, transition to Wandering
(Action) Move toward enemy unless closer than 400 Unreal units, back up instead; Also move left or right randomly</Text>
        </Document>
        <Document ID="124">
            <Title>Fleeing</Title>
            <Synopsis>Bot is trying to escape from the enemy</Synopsis>
            <Text>Fleeing
(Action) Move away from enemy
If Has Ammo AND In Attack Range of Enemy AND Knows Enemy Location  AND NOT In Mortal Danger, transition to Attacking
If Needs Health and Near Health, transition to Collecting Health
If Needs Ammo and Near Ammo or Weapon and can use that ammo or weapon, transition to Collecting Ammo or Weapon
After 10 seconds, transition to patrolling
If NOT Suspects Enemy Location, transition to Wandering</Text>
        </Document>
        <Document ID="125">
            <Title>Patrolling</Title>
            <Synopsis>Bot is going from waypoint to waypoint to guard his territory</Synopsis>
            <Text>Patrolling
If there are no waypoints, transition to Wandering
(Action) If there is a Focused Waypoint, make that the next waypoint then clear the Focused Waypoint
(Action) go to next waypoint, then increment waypoint
If Needs Health, transition to Finding Health
If Needs Ammo, transition to Finding Ammo or Weapon
If suspects enemy location, transition to Attacking.
If Near Another Bot that is Attacking, transition to Attacking With Teammate
If Near Another Bot that is Fleeing, transition to Defending Teammate
If Wants Health and Near Health, transition to Collecting Health
If Wants Ammo and Near Ammo or Weapon and (Weapon is not Full OR doesn’t have weapon), transition to Collecting Ammo or Weapon
If Near Powerup and NOT Focused Powerup is Full, transition to Collecting Powerup
If Bored, transition to Wandering</Text>
        </Document>
        <Document ID="126">
            <Title>Wandering</Title>
            <Synopsis>Bot is wandering randomly through the level</Synopsis>
            <Text>Wandering
(Action) Move randomly, avoiding obstacles
If Needs Health, transition to Finding Health
If Needs Ammo, transition to Finding Ammo or Weapon
If suspects enemy location, transition to Attacking.
If Near Another Bot Neither Attacking nor Fleeing, transition to Patrolling
If Near Another Bot that is Attacking, transition to Attacking With Teammate
If Near Another Bot that is Fleeing, transition to Defending Teammate
If Wants Health and Near Health, transition to Collecting Health
If Wants Ammo and Near Ammo or Weapon and can use that ammo or weapon, transition to Collecting Ammo or Weapon
If Near Powerup and can use that powerup, transition to Collecting Powerup
If Far From Home, transition to Patrolling</Text>
        </Document>
        <Document ID="127">
            <Title>Finding Health</Title>
            <Synopsis>Bot is looking for a health pickup</Synopsis>
            <Text>Finding Health
If Knows Location of Health, transition to Collecting Health
Otherwise, transition to Wander</Text>
        </Document>
        <Document ID="128">
            <Title>Finding Ammo or Weapon</Title>
            <Synopsis>Bot is looking for an ammo or weapon pickup</Synopsis>
            <Text>Finding Ammo or Weapon
If Knows Location of Ammo or Weapon, transition to Collecting Ammo or Weapon
Otherwise transition to Wander</Text>
        </Document>
        <Document ID="129">
            <Title>Collecting Health</Title>
            <Synopsis>Bot is headed for a known health pickup</Synopsis>
            <Text>Collecting Health
(Action) Move toward Focused Health
On collection of Health, or failure, transition to Wander</Text>
        </Document>
        <Document ID="130">
            <Title>Collecting Ammo or Weapon</Title>
            <Synopsis>Bot is headed for a known ammo or weapon pickup</Synopsis>
            <Text>Collecting Ammo or Weapon
(Action) Move toward Focused Ammo or Weapon
On collection of Ammo or Weapon, or failure, transition to Wander</Text>
        </Document>
        <Document ID="131">
            <Title>Collecting Powerup</Title>
            <Synopsis>Bot is headed for a known powerup</Synopsis>
            <Text>Collecting Powerup
(Action) Move toward Focused Powerup
On collection of Powerup, or failure, transition to Wander</Text>
        </Document>
        <Document ID="132">
            <Title>Defending Teammate</Title>
            <Synopsis>Bot is attempting to attack an enemy that another bot is fleeing from</Synopsis>
            <Text>Defending Teammate
If Suspects Enemy Location AND (In Mortal Danger OR NOT Has Ammo), transition to Fleeing
(Action) Move toward Focused Bot Backward
If Knows Enemy Location, transition to Attacking
If NOT Near Another Bot that is Fleeing, transition to Wandering</Text>
        </Document>
        <Document ID="133">
            <Title>Attacking With Teammate</Title>
            <Synopsis>Bot is attempting to attack an enemy that another bot is also attacking</Synopsis>
            <Text>Attacking With Teammate
If Suspects Enemy Location AND (In Mortal Danger OR NOT Has Ammo), transition to Fleeing
(Action) Move toward Focused Bot Forward
If Knows Enemy Location, transition to Attacking
If NOT Near Another Bot that is Attacking, transition to Wandering</Text>
        </Document>
        <Document ID="134">
            <Title>Key Base</Title>
            <Synopsis>Keys for accessing locked areas of a level</Synopsis>
            <Text>Key Base</Text>
        </Document>
        <Document ID="135">
            <Title>Powerup Base</Title>
            <Synopsis>Gives additional abilities to a character</Synopsis>
            <Text>Powerup Base</Text>
        </Document>
        <Document ID="136">
            <Title>Ammo Base</Title>
            <Synopsis>Reloads a character's weapon</Synopsis>
            <Text>Ammo Base</Text>
        </Document>
        <Document ID="137">
            <Title>Weapon Base</Title>
            <Synopsis>Used by a character to attack another character</Synopsis>
            <Text>Weapon Base 
file:///D:/Documents/Repos/Deplorable_Mountaineer/Spreadsheets/Weapon.ods

Also current ammo, last-fire-time
Weapon types include:
Hitscan (beam, fast projectile, or invisible), Projectile (particle or mesh), Bouncing Projectile (grenade), Controllable Projectile, Homing Projectile, Sticky Projectile (Mine), Wide-angle hit (flame thrower).  
Effects on target include damage to health and physics.  Can add other effects, like stealing powerups.</Text>
        </Document>
        <Document ID="138">
            <Title>Comparison of Weapons</Title>
            <Synopsis>Matrix of weapon capabilities for balancing purposes</Synopsis>
            <Text>Comparison of Weapons
file:///D:/Documents/Repos/Deplorable_Mountaineer/Spreadsheets/Weapon_Comparison.ods</Text>
        </Document>
        <Document ID="139">
            <Title>Stair builder</Title>
            <Synopsis>Stairs with an arbitrary number of steps</Synopsis>
            <Text>Stair builder
	Enter the number of steps.  Default step has a rise and run both of 15.  If using a different step mesh, it must have a socket named “Next” for the next step.  
To ensure bots can walk up and down the stairs, click the RecastNavMesh actor and change Cell Height to 22.5.</Text>
        </Document>
        <Document ID="140">
            <Title>Pipe builder</Title>
            <Synopsis>Piping with configurable extent and bending</Synopsis>
            <Text>Pipe builder</Text>
        </Document>
        <Document ID="141">
            <Title>Fence builder</Title>
            <Synopsis>Configurable-length fence</Synopsis>
            <Text>Fence builder</Text>
        </Document>
        <Document ID="143">
            <Title>Hose Builder</Title>
            <Synopsis>Like a pipe, but with a spline for maximum bendability</Synopsis>
            <Text>Hose Builder</Text>
        </Document>
        <Document ID="144">
            <Title>Railing builder</Title>
            <Synopsis>Like a fence, but mainly for on steps or balconies</Synopsis>
            <Text>Railing builder</Text>
        </Document>
        <Document ID="145">
            <Title>Jump pad</Title>
            <Synopsis>Launches a character to somewhere else</Synopsis>
            <Text>Jump pad
	Use any actor for jump target (suggested: Target Point actor).  Set this in the Target property of the jump pad.  If jump pad fails, it could be that there is no solution in the velocity range given, so try changing the min speed and max speed.  Use the curved beam to help with positioning (it can be left on or turned off in game—it only gives the approximate path, since it is a spline and not a parabola).  The landing area should be at least as large as the jump pad’s trigger volume (default radius of 80 so landing area needs diameter of 160 or more) because of inaccuracies due to approaching the pad from different directions.</Text>
        </Document>
        <Document ID="146">
            <Title>Placeable shooters</Title>
            <Synopsis>An automatic turret</Synopsis>
            <Text>Placeable shooters</Text>
        </Document>
        <Document ID="147">
            <Title>Day and night skies</Title>
            <Synopsis>Sky spheres for in levels</Synopsis>
            <Text>Day and night skies</Text>
        </Document>
        <Document ID="148">
            <Title>Lighted signs</Title>
            <Synopsis>Signs with changeable message</Synopsis>
            <Text>Lighted signs</Text>
        </Document>
        <Document ID="149">
            <Title>Monitors</Title>
            <Synopsis>For TV or computer in level, or connected to a security camera</Synopsis>
            <Text>Monitors</Text>
        </Document>
        <Document ID="150">
            <Title>security cameras</Title>
            <Synopsis>Transmits an image to a monitor actor</Synopsis>
            <Text>security cameras</Text>
        </Document>
        <Document ID="151">
            <Title>Teleporter</Title>
            <Synopsis>Transmits actors across the level instantaneously</Synopsis>
            <Text>Teleporter</Text>
        </Document>
        <Document ID="152">
            <Title>Spawner</Title>
            <Synopsis>Materializes actors in the level</Synopsis>
            <Text>Spawner</Text>
        </Document>
        <Document ID="153">
            <Title>Fan</Title>
            <Synopsis>A fan object in the level</Synopsis>
            <Text>Fan</Text>
        </Document>
        <Document ID="154">
            <Title>Collision</Title>
            <Synopsis>Collision profiles and trace channels</Synopsis>
            <Text>Collision
Note, most values are the UE4 Defaults.

file:///D:/Documents/Repos/Deplorable_Mountaineer/Spreadsheets/Collision.ods</Text>
        </Document>
        <Document ID="155">
            <Title>Physical Surfaces</Title>
            <Synopsis>Properties of various surfaces in the game</Synopsis>
            <Text>Physical Surfaces
These values are for game purposes—in some cases I just made them up.
file:///D:/Documents/Repos/Deplorable_Mountaineer/Spreadsheets/PhysicalSurfaces.ods</Text>
        </Document>
        <Document ID="156">
            <Title>Door Actions</Title>
            <Synopsis>Things a door can do</Synopsis>
            <Text>Door Actions
Open
Close
Open Reverse
Close Reverse
Lock
Unlock
Operate
If operated from -X direction:
if open, close
if open reverse, close reverse
if closed and unlocked, open
If operated from X direction
if open, close
if open reverse, close reverse
if closed and unlocked and reversible, open reverse
if closed and unlocked and not reversible, open (note sliding doors typically not reversible)</Text>
        </Document>
        <Document ID="157">
            <Title>Door Properties</Title>
            <Synopsis>Variables a door maintains</Synopsis>
            <Text>Door Properties
Auto Close Delay: if 0, never auto close, otherwise after delay of that many seconds
Open Speed
Close Speed
Auto Open: if character is in trigger volume, opens automatically
Auto Open Reverse: if character is in reverse trigger volume, opens automatically in reverse
Operatable: “operate” opens the door; otherwise need to find a switch somewhere.
reversible: if false, open reverse fails.
Locked: if true, open and open reverse fail; if physics mode and closed, door becomes immovable
open state, closed state, open reversed state</Text>
        </Document>
        <Document ID="158">
            <Title>Light Actions</Title>
            <Synopsis>Things a light can do</Synopsis>
            <Text>Light Actions
Actions typically follow a curve (ease-in ease-out) though some lights might have other behavior (E.G. fluorescent light flicker).
On: turn on to previous dimmer amount
Off: turn off regardless of dimmer amount
Toggle: (usual action for Operate)
if on, turn off regardless of dimmer amount.
If off, turn on to previous dimmer amount.
Set Dimmer Amount: value from 0 to 1, min brightness to max brightness
Set Light Color
Set Light Direction</Text>
        </Document>
        <Document ID="159">
            <Title>Light Properties</Title>
            <Synopsis>Variables a light maintains</Synopsis>
            <Text>Light Properties
Max Brightness
Min Brightness (for dimmer, nonzero for technical reasons, but can be so near 0 it is essentially off)
Direction (rotator): direction a light faces, if applicable
Color 
Dimmer Amount (from 0 to 1)</Text>
        </Document>
        <Document ID="160">
            <Title>Switch Actions</Title>
            <Synopsis>Things a switch can do</Synopsis>
            <Text>Switch Actions
Toggle: Change to next state (states are ordered in an array by integer; next state is the next-indexed state)
Set State: set to one of the states available to the switch.</Text>
        </Document>
        <Document ID="161">
            <Title>Switch Properties</Title>
            <Synopsis>State maintained by a switch</Synopsis>
            <Text>Switch Properties
State: usually on or off, though could be more; represented by a value of type “Name”
On Enter State: mapping from states to actions on a controlled object (door, light, etc.); action taken when state is entered.
On Exit State: mapping from states to actions on a controlled object (door, light, etc.); action taken when state is exited.</Text>
        </Document>
        <Document ID="162">
            <Title>Main Menu</Title>
            <Synopsis>Menu that appears when the game is first run</Synopsis>
            <Text>Main Menu

￼

Available choices: New Game, Load Game, Options, Statistics, Quit
The main menu is brought up by the BeginPlay event of the Level Blueprint of the Entry map.  This same level blueprint has properties UI Colors and UI Text for changing various menu properties for all menus.

New Game: Select Skill, Select Episode, Play, Return
￼

Load Game: Select Game, Play, Return
￼
Options: Action Input, Mouse and Axis Input, Graphics and Sound, Weapons, Return
￼
Action Input: Add New Key Binding, Remove Selected Key Binding
￼
Mouse and Axis Input: invert mouse, mouse sensitivity
Statistics: top scores, achievements
Graphics and Sound: Resolution, Effects Volume, Music Volume
Weapons: Priority,  Auto Switch on Pickup (always, never, if better) Switch to Best Weapon when Out of Ammo</Text>
        </Document>
        <Document ID="163">
            <Title>Main Menu Classes</Title>
            <Synopsis>Blueprints used with the main menu</Synopsis>
            <Text>Main Menu Classes
BP_Pawn_Menu: 
Maintains Last Key Pressed, Last Key or Modifier Pressed, and Last Chord Pressed
Chord to Text function
Clear Keys event
MainMenu_GameMode:
Get Bindings
Action Key Mapping to Text
Debug Print Bindings
Axis Key Mapping to Text
BP_MainMenu (HUD class):
Event Play Game
Maintains array of First Levels of Episodes
Sets input mode to UI and game, and shows mouse cursor for menu use</Text>
        </Document>
        <Document ID="164">
            <Title>Pause Menu</Title>
            <Synopsis>Menu that can be opened from within a game</Synopsis>
            <Text>Pause Menu</Text>
        </Document>
        <Document ID="165">
            <Title>HUD</Title>
            <Synopsis>On-screen data shown during a game</Synopsis>
            <Text>HUD

Ammo on bottom right, change color when low, with flash when it turns low and audible noise;
￼
Radar Top right (as a powerup?), different color for enemies that are close; compass style
Health on bottom left; flash, audio warning when turns low, change color when low.
￼
Next to health are Strength, Shield, and Keys.
￼￼￼

Next to ammo are the powerups: Turbo, Night vision, Lift belt, and Radar.TODO: update this when finalized
￼

Crosshair: fine lines, duplex (outer parts of lines highlighted); also dot and range-finding for long-range weapons.</Text>
        </Document>
        <Document ID="166">
            <Title>Health</Title>
            <Synopsis>The character's health--0 means dead, 100 means full health, and more than 100 is super-health</Synopsis>
            <Text>Health
On picking up a health item, its value is added to the current health, capped at 100 (no cap if it is a super health item).  If there is no change in health from the item, the item will not be picked up.
On taking damage, the health is diminished by the modified amount of damage, where the amount of damage is modified both by strength and amount of shielding possessed.  Sometimes damage is multiplied if it hits certain bones instead of others (such as a head shot).</Text>
        </Document>
        <Document ID="167">
            <Title>Strength</Title>
            <Synopsis>Character strength--affects speeds and distances for character motion as well as damage taken.  For the player, increases swith experience</Synopsis>
            <Text>Strength
The strength of most NPCs is fixed according to the character the NPC represents.  The strength of the player can increase with “experience.”  The strength can temporarily increase upon consuming a turbo power boost (“Nitro”) power up, but reverts when the power up runs out.</Text>
        </Document>
        <Document ID="168">
            <Title>Current Weapon Slot</Title>
            <Synopsis>Index of the weapon currently held, or 0 if no weapon.</Synopsis>
            <Text>Current Weapon Slot
This is the slot number of the weapon currently being carried.  Weapons are numbered from 1 through unlimited (no hard limit to number of weapons, but only 1 through 9 can be selected by a keypress, others must be scrolled to with the scroll wheel, for example).  It is changed when a weapon is dropped or selected.  If dropped or tossed or stashed, the slot changes to 0 (no weapon).  If selected (manually, or if auto-select is triggered in certain cases), it changes to whatever weapon slot is selected.</Text>
        </Document>
        <Document ID="169">
            <Title>Third Person Mode</Title>
            <Synopsis>Mode where camera follows the character</Synopsis>
            <Text>Third Person Mode
If true, the character is in third-person mode (relevant to player only).</Text>
        </Document>
        <Document ID="170">
            <Title>Enemies Killed</Title>
            <Synopsis>List of all enemies killed, for statistics purposes</Synopsis>
            <Text>Enemies Killed
A list of unique names of enemies killed, for statistics purposes.  Added to whenever this character kills someone, and reset on starting or restarting a level.</Text>
        </Document>
        <Document ID="171">
            <Title>Secrets Found</Title>
            <Synopsis>List of all secrets found, for statistics purposes</Synopsis>
            <Text>Secrets Found
A list of names of secrets found, for statistics purposes.  Secrets given the same name will be considered the same secret and not be counted more than once.  Added to whenever this character overlaps a “Secret Area” volume not yet found, and reset on starting or restarting a level.</Text>
        </Document>
        <Document ID="172">
            <Title>Powerups Found</Title>
            <Synopsis>List of all powerups found, for statistics purposes</Synopsis>
            <Text>Powerups Found
A list of unique names of powerups found, for statistics purposes.  Added to whenever a character walks over or attempts to pick up a powerup, whether or not successful, and reset on starting or restarting a level.</Text>
        </Document>
        <Document ID="173">
            <Title>Weapons Found</Title>
            <Synopsis>List of all weapons found, for statistics purposes</Synopsis>
            <Text>Weapons Found
A list of unique names of weapons found, for statistics purposes.  Added to whenever a character walks over or attempts to pick up a weapon, whether or not successful, and reset on starting or restarting a level.</Text>
        </Document>
        <Document ID="174">
            <Title>Ammo Found</Title>
            <Synopsis>List of all ammo pickups found, for stastical purposes</Synopsis>
            <Text>Ammo Found
A list of unique names of ammo pickups found, for statistics purposes.  Added to whenever a character walks over or attempts to pick up ammo, whether or not successful, and reset on starting or restarting a level.</Text>
        </Document>
        <Document ID="175">
            <Title>Health Found</Title>
            <Synopsis>List of all health pickups found, for statistical purposes</Synopsis>
            <Text>Health Found
A list of unique names of health pickups found, for statistics purposes.  Added to whenever a character walks over or attempts to pick up health, whether or not successful, and reset on starting or restarting a level.</Text>
        </Document>
        <Document ID="176">
            <Title>Keys Found</Title>
            <Synopsis>List of all keys found, for statistical purposes and character access control in a level</Synopsis>
            <Text>Keys Found
A list of names of keys found, for statistics purposes, and to determine if character can pass through certain areas or not.  Keys with the same name are considered equal.  Added to whenever a character picks up a key not yet found, and reset on starting or restarting a level.</Text>
        </Document>
        <Document ID="177">
            <Title>Falling Counter</Title>
            <Synopsis>Time character has been falling at a sufficient velocity for harm</Synopsis>
            <Text>Falling Counter
How long (in seconds) a character has been falling at more than a specified minimum velocity, used to compute damage from falling.  It is incremented while the character is falling at greater than the minimum velocity, and reset when the player lands (whence damage is taken if appropriate).</Text>
        </Document>
        <Document ID="178">
            <Title>FOV</Title>
            <Synopsis>Field of view, changed by zooming in or out</Synopsis>
            <Text>FOV
Field of view in degrees, relevant only to the player.  Adjusted when the player changes zoom level.</Text>
        </Document>
        <Document ID="179">
            <Title>Carried Item</Title>
            <Synopsis>Data on the item being carried by the character, if any</Synopsis>
            <Text>Carried Item
A struct holding data for the item currently being carried (so it can be reproduced on loading a saved game).  It is modified when a player picks up or drops a physics item.</Text>
        </Document>
        <Document ID="180">
            <Title>Inventory</Title>
            <Synopsis>List of items the character posesses</Synopsis>
            <Text>Inventory
An array of structs, each of which holds data for an inventory item being carried (so it can be reproduced on loading a saved game).  It is modified when a player picks up or drops an inventory item of the type that stays with the character (such as a weapon).</Text>
        </Document>
        <Document ID="181">
            <Title>Third Person Camera Arm Length</Title>
            <Synopsis>How far the following camera is behind the player</Synopsis>
            <Text>Third Person Camera Arm Length
Follow distance of the third-person camera.  Relevant only for the player, and then only in third-person mode.  Can be adjusted by the player.</Text>
        </Document>
        <Document ID="182">
            <Title>State Machine</Title>
            <Synopsis>The overall state machine for teh character's animation</Synopsis>
            <Text>State Machine
￼</Text>
        </Document>
        <Document ID="183">
            <Title>Idle</Title>
            <Synopsis>State when character is just standing there</Synopsis>
            <Text>Idle
The entry state.  Idle animation.  
If Jump is enabled and Horizontal Speed is less than 10, transition to the Jump state.
If Jump is not enabled and Falling is true, transition to the Fall state.
If Horizontal Speed is greater than or equal to 10, transition to the Jog state.
If Crouching is true, transition to the Crouch state.</Text>
        </Document>
        <Document ID="184">
            <Title>Jog</Title>
            <Synopsis>State when character is walking or running</Synopsis>
            <Text>Jog
Blend Space BS_Jog animation, parametrized by Direction and Horizontal Speed.
If Horizontal Speed is less than 10, transition to the Idle state.
If Horizontal Speed is greater than or equal to 10 and Jump is enabled, transition to the Run Jump state.
If Falling is true and Jump is not enabled, transition to the Fall state.
If Crouching is true, transition to the Crouch Walk state.</Text>
        </Document>
        <Document ID="185">
            <Title>Run Jump</Title>
            <Synopsis>State when character is jumping while running</Synopsis>
            <Text>Run Jump
Jump from Jog animation.
If animation done and falling, transition to Fall state.
If animation done and not falling, transition to Jog state.</Text>
        </Document>
        <Document ID="186">
            <Title>Fall</Title>
            <Synopsis>State when character is in free fall</Synopsis>
            <Text>Fall
Idle animation.
If not Falling and Horizontal Speed is greater than or equal to 10, transition to Jog state.
If not Falling and Horizontal Speed is less than 10, transition to Idle state.</Text>
        </Document>
        <Document ID="187">
            <Title>Jump</Title>
            <Synopsis>State when character jumps from standing idle</Synopsis>
            <Text>Jump
Jump from Stand animation.
If animation finished and falling, transition to Fall state.
If animation finished and not falling, transition to Idle state.</Text>
        </Document>
        <Document ID="188">
            <Title>Crouch</Title>
            <Synopsis>State when character crouches from standing idle</Synopsis>
            <Text>Crouch
Crouch Idle animation.
If not Crouching, transition to Idle state.
If Horizontal Speed is greater than or equal to 10, transition to Crouch Walk state.</Text>
        </Document>
        <Document ID="189">
            <Title>Crouch Walk</Title>
            <Synopsis>State when character walks while crouched</Synopsis>
            <Text>Crouch Walk
Blend Space BS_CrouchWalk parametrized by Direction and Horizontal Speed.
If not Crouching, transition to Jog state.
If Horizontal Speed is less than 10, transition to Crouch state.</Text>
        </Document>
        <Document ID="190">
            <Title>Health Base</Title>
            <Synopsis>Increases a character's health</Synopsis>
            <Text>Health Base
Two properties: Amount (of health to be added when picked up, float), and Super (if true, ignores the maximum of 100 health points, Boolean).</Text>
        </Document>
        <Document ID="191">
            <Title>Game Information Body</Title>
            <Text>
￼
Unique Project ID: {AED64A86-47D8-D36A-F0A9-2093602951A6}
Name: Classic FPS Version 0.01
Description: Classic first person shooter project for Unreal Engine 4 in the style of the original single-player Doom, Unreal, Quake, and so on.
Company: Deplorable Mountaineer
Website: https://deplorablemountain.wixsite.com/games
Copyright: © 2018 Deplorable Mountaineer
Contact: Deplorable.Mountaineer@gmail.com
Palette Colors: #38c098, #F8BE00, #B52930, #10655E, #ffffff, #42484f, #1EF858, #F89245, #A057F8, #45F8B5, #613F29
￼

Palette Gradient:
￼</Text>
            <Notes>

</Notes>
        </Document>
        <Document ID="192">
            <Title>Folder Structure Body</Title>
            <Text>Under Content:
├───AnimStarterPack
│   └───UE4_Mannequin
│       ├───Materials
│       │   └───MaterialLayers
│       ├───Mesh
│       └───Textures
├───ClassicFPS
│   ├───Base
│   │   ├───Blueprints
│   │   ├───Icons
│   │   ├───MaterialMasters
│   │   │   ├───Data
│   │   │   └───Functions
│   │   └───Physmats
│   │       └───Data
│   ├───Characters
│   │   ├───Animations
│   │   │   ├───AnimationSequences
│   │   │   ├───Blueprints
│   │   │   └───FirstPerson
│   │   ├───Data
│   │   ├───Materials
│   │   │   └───Textures
│   │   ├───NPC
│   │   │   └───Data
│   │   └───Player
│   │       └───Data
│   ├───Dev
│   ├───Effects
│   │   ├───Controllable
│   │   ├───Materials
│   │   │   ├───Ceramic
│   │   │   ├───Data
│   │   │   ├───Decals
│   │   │   │   └───Textures
│   │   │   ├───Fabric
│   │   │   │   └───Textures
│   │   │   ├───FloorCeiling
│   │   │   │   └───Textures
│   │   │   ├───FluidAndIce
│   │   │   ├───Glass
│   │   │   │   └───Textures
│   │   │   ├───Glow
│   │   │   ├───Ground
│   │   │   │   └───Textures
│   │   │   ├───Metal
│   │   │   │   ├───Painted
│   │   │   │   │   └───Textures
│   │   │   │   └───Textures
│   │   │   ├───Paper
│   │   │   │   └───Textures
│   │   │   ├───Plastic
│   │   │   ├───Rock
│   │   │   │   └───Textures
│   │   │   ├───Rubber
│   │   │   │   └───Textures
│   │   │   ├───Special
│   │   │   ├───Textures
│   │   │   ├───Wall
│   │   │   │   └───Textures
│   │   │   └───Wood
│   │   │       └───Textures
│   │   └───Particles
│   │       └───Materials
│   ├───Environment
│   │   ├───Background
│   │   ├───Buildings
│   │   │   ├───Commercial
│   │   │   ├───Fixtures
│   │   │   ├───Furniture
│   │   │   ├───Pipes
│   │   │   └───Residential
│   │   ├───Foliage
│   │   ├───Landscape
│   │   │   └───Rocks
│   │   ├───Props
│   │   │   ├───Lights
│   │   │   │   └───Meshes
│   │   │   ├───Meshes
│   │   │   └───Shapes
│   │   ├───Sky
│   │   └───Water
│   ├───Gameplay
│   ├───Maps
│   │   ├───Episode_01
│   │   ├───Episode_02
│   │   ├───Episode_03
│   │   └───TestMaps
│   ├───Pickups
│   │   ├───Health
│   │   ├───Keys
│   │   ├───Powerups
│   │   │   └───Permanent
│   │   └───Weapons
│   │       ├───Ammo
│   │       ├───Materials
│   │       │   └───Textures
│   │       │       └───Crosshairs
│   │       └───Rifle
│   ├───PostProcess
│   ├───Sound
│   ├───UI
│   │   ├───HUD
│   │   │   └───Materials
│   │   ├───MainMenu
│   │   │   └───Materials
│   │   ├───Monitor
│   │   └───PauseMenu
│   └───Vehicles
├───Collections
├───Developers
│   └───tdvance
│       └───Collections
├───FirstPerson
│   ├───Animations
│   ├───Audio
│   ├───Character
│   │   ├───Materials
│   │   │   └───MaterialLayers
│   │   ├───Mesh
│   │   └───Textures
│   ├───FPWeapon
│   │   ├───Materials
│   │   │   └───MaterialLayers
│   │   ├───Mesh
│   │   └───Textures
│   ├───Meshes
│   └───Textures
├───FirstPersonBP
│   ├───Blueprints
│   └───Maps
├───Geometry
│   └───Meshes
├───Mannequin
│   ├───Animations
│   └───Character
│       ├───Materials
│       │   └───MaterialLayers
│       ├───Mesh
│       └───Textures
├───ThirdPerson
│   └───Meshes
└───ThirdPersonBP
    ├───Blueprints
    └───Maps</Text>
        </Document>
        <Document ID="193">
            <Title>ClassicFPS_GPDD</Title>
        </Document>
    </Documents>
</SearchIndexes>
